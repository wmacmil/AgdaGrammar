{-# OPTIONS --omega-in-omega --type-in-type #-}

open import Agda.Builtin.Sigma public


data _‚â°_ {A : Set} (a : A) : A ‚Üí Set where
  r : a ‚â° a

infix 20 _‚â°_

id : {A : Set} ‚Üí A ‚Üí A
id = Œª z ‚Üí z

iscontr : (A : Set) ‚Üí Set
iscontr A =  Œ£ A Œª a ‚Üí (x : A) ‚Üí (a ‚â° x)

fiber : (A B : Set) (f : A -> B) (y : B) ‚Üí Set
fiber A B f y = Œ£ A (Œª x ‚Üí y ‚â° f x) -- (x : A) * Path B y (f x)

isEquiv : (A B : Set) ‚Üí (f : A ‚Üí B) ‚Üí Set
isEquiv A B f = (y : B) ‚Üí iscontr (fiber A B f y)  -- {!!} ‚Üí {!!} -- ( y : b ) -> isContr ( fiber a b f y )

singl : (A : Set) (a : A) ‚Üí Set
singl A a = Œ£ A (Œª x ‚Üí a ‚â° x) -- = (x : A) * Path A a x

contrSingl : (A : Set) (a b : A) (p : a ‚â° b) ‚Üí  _‚â°_ {singl A a} (a , r ) (b , p)
contrSingl A a .a r = r

-- -- proof from cubical notes
idIsEquiv : (A : Set) ‚Üí isEquiv A A (id {A})
idIsEquiv A y = (y , r) , Œª x ‚Üí contrSingl A y (fst x) (snd x)
-- idIsEquiv A y = (y , r) , Œª x ‚Üí let fs = fst x
--                                     sn = snd x
--                                     in contrSingl A y fs sn --contrSingl A y (fst x) (snd x)

-- proof from Aarne
idIsEquiv' : (A : Set) ‚Üí isEquiv A A (id {A})
idIsEquiv' A y = ybar , Œª { (a , r) ‚Üí r}
  where
    fib : Set
    fib = Œ£ A (Œª x ‚Üí y ‚â° x)
    ybar : fib
    ybar = y , r

-- before pattern matching b : y ‚â° id a
equiv : ( a b : Set ) ‚Üí Set
equiv a b = Œ£ (a ‚Üí b) Œª f ‚Üí isEquiv a b f -- (f : A -> B) * isEquiv A B f

-- perhaps misformulated
eqToIso : ( a b : Set ) ‚Üí _‚â°_ {Set} a b ‚Üí equiv a b
eqToIso a .a r = id , idIsEquiv' a


-- it breaks down --

-- equiv' : (u : Set‚ÇÅ) ( a b : u ) ‚Üí Set
-- equiv' u a b = Œ£ (a ‚Üí b) Œª f ‚Üí isEquiv a b f -- (f : A -> B) * isEquiv A B f

-- eqToIso' : (u : Set) ( a b : u ) ‚Üí _‚â°_ a b ‚Üí equiv' u {!!} {!!}
-- eqToIso' u a b = {!!}

mymap : (a b : Set) ‚Üí Set
mymap a b = _‚â°_ {Set} a b ‚Üí equiv a b


Id‚ÜíEq : (X Y : Set ) ‚Üí X ‚â° Y ‚Üí equiv X Y
Id‚ÜíEq X .X r = (Œª z ‚Üí z) , idIsEquiv X

-- is-univalent : (u : Set) ‚Üí u -- ‚Å∫ Ãá
-- is-univalent u = (X Y : u ) ‚Üí isEquiv ? ? (Id‚ÜíEq X Y)

-- is-univalent : (ùì§ : Universe) ‚Üí ùì§ ‚Å∫ Ãá
-- is-univalent ùì§ = (X Y : ùì§ Ãá ) ‚Üí is-equiv (Id‚ÜíEq X Y)

-- setEquiv : Set
-- setEquiv = (a b : Set) ‚Üí isEquiv ? ? ((_‚â°_ a b) ‚Üí (equiv a b))

-- univU : Set ‚Üí Set
-- univU u = (a b : u) ‚Üí isEquiv ? ? (_‚â°_ a b ‚Üí equiv a b) -- {!_‚â°_ {Set} a b ‚Üí equiv a b!} 

-- what is this unreachable clause stuff?
-- -- proof from cubical notes
-- idIsEquiv : (A : Set) ‚Üí isEquiv A A (id {A})
-- idIsEquiv A y = (y , r) , Œª x ‚Üí contrSingl A y (fst x) (snd x)
-- idIsEquiv A y = (y , r) , Œª x ‚Üí let fs = fst x ; sn = snd x in contrSingl A y fs sn --contrSingl A y (fst x) (snd x)


--fucking around


record Œ£' (A : Set) (B : A ‚Üí Set) : Set where
  -- constructor _,'_
  field
    fst' : A
    snd' : B fst'

open Œ£'

-- Œ£'->Œ£ : (A : Set) (B : A ‚Üí Set) ‚Üí Œ£' A B ‚Üí Œ£ A B
-- Œ£'->Œ£ a b s = let fs = fst' s
--                   sn = snd' s
--                   in {!!} -- fs , sn

-- Œ£'->Œ£ : (A : Set) (B : A ‚Üí Set) ‚Üí Œ£' A B ‚Üí Œ£ A B
-- Œ£'->Œ£ a b s = fst' s , snd' s

-- Œ£'->Œ£ : (A : Set) (B : A ‚Üí Set) ‚Üí Œ£' A B ‚Üí Œ£ A B
-- Œ£'->Œ£ a b record { fst = fst ; snd = snd } = fst , snd

-- Œ£'->Œ£ : (A : Set) (B : A ‚Üí Set) ‚Üí Œ£' A B ‚Üí Œ£ A B
-- Œ£'->Œ£ A B (fst‚ÇÅ ,' snd‚ÇÅ) = fst‚ÇÅ , snd‚ÇÅ



--cant do without insane amoutns of work
-- -- proof from Aarne
-- idIsEquiv'' : (A : Set) ‚Üí isEquiv A A (id {A})
-- idIsEquiv'' A y = ybar , Œª { (a , b) ‚Üí {!!}} -- helper
--   where
--     fib : Set
--     fib = Œ£ A (Œª x ‚Üí y ‚â° x)
--     ybar : fib
--     ybar = y , r
--     helper : (x : fiber A A id y) ‚Üí ybar ‚â° x
--     -- helper (a , r) = r
--     -- helper x = let fs = fst x ; sn = snd x in {!helper2 !} -- contrSingl A y fs sn --r
--     helper x =  {!helper2 !} -- contrSingl A y fs sn --r
--       where
--         fs : A
--         fs = fst x
--         sn : y ‚â° id fs
--         sn = snd x
--         helper2 : ybar ‚â° x
--         helper2 = {!!}
